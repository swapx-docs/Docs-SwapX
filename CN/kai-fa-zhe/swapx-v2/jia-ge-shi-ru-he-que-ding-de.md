# 🏷️ 价格是如何确定的？

### 🏷️ 价格是如何确定的？

正如我们在协议概述中了解到的，SwapX 上的每对实际上都由一个流动性池支撑。流动性池是智能合约，它持有两种不同代币的余额，并执行有关存入和提取它们的规则。

其主要规则是恒定乘积公式（$$ $x \times y = k$ $$）。

当提取（购买）一种代币时，必须存入（出售）一定比例的另一种代币以保持该恒定值。池中代币的比例与恒定乘积公式相结合，最终决定了掉期（Swap）执行的价格。

***

### ⚙️ SwapX 如何处理价格

#### V1：链上计算

在 SwapX V1 中，交易总是以“最佳”价格执行，并在执行时进行计算。这个计算实际上是用了两个不同的公式之一来完成的，具体取决于交易是指定了确切的输入还是输出金额。从功能上讲，这两个函数之间的差异很小，但差异的存在本身就增加了概念的复杂性。

#### V2：外围定价

最初在 V2 中支持这两个函数的尝试被证明是不雅的。因此，团队决定不在核心合约中提供任何定价函数。

取而代之的是，V2 交易对合约在每次交易后直接检查不变量（$$ $x \times y = k$ $$）是否得到满足（已考虑费用）。

这种方法有两个主要好处：

1. 关注点分离： V2 不是依靠定价函数来强制执行不变量，而是简单透明地确保自己的安全，这是一个很好的关注点分离。
2. 灵活性： V2 交易对将更自然地支持可能出现的其他交易类型（例如，在执行时以特定价格交易）。

从高层次来看，在 SwapX V2 中，交易必须在外围定价（即由核心交易&#x5BF9;_&#x4E4B;&#x5916;_&#x7684;合约定价）。

好消息是，SwapX 库 提供了各种旨在使此过程变得非常简单的功能，并且路由器中的所有交换功能都是考虑到这一点而设计的。

***

### 📈 交易定价

在 SwapX 上交换代币时，您通常希望达到以下两个目的之一：

1. 以确切的输入金额换取尽可能多的输出代币。
2. 以尽可能少的输入代币获得确切的输出金额。

为了计算这些金额，合约必须查找该交易对的当前准备金，以了解当前价格是多少。

#### 预言机问题

然而，如果无法访问外部价格（预言机），执行此查找并依赖结果是不安全的。

假设一个“天真”的智能合约想要向 DAI/WETH 交易对发送 10 DAI，并在当前准备金率的情况下接收尽可能多的 WETH。如果这个天真的合约在调用时只是查找当前价格并执行交易，那么它很容易受到抢先交易 (Front-running) 的攻击，并可能遭受经济损失。

要了解原因，请考虑一个在交易确认之前看到此交易的恶意行为者：

1. 攻击者在天真合约的交换完成之前立即执行一次掉期，从而大幅改变 DAI/WETH 的价格。
2. 天真合约的交换以这个新的、不利的汇率执行。
3. 攻击者随后进行反向交换，将价格改回天真合约交换之前的价格，并从中获利。

这种攻击相当便宜且风险低，通常可以获利。

#### 解决方案：预言机与滑点

为了防止此类攻击，提交交换时必须能够了解其交换应以执行的“公平”价格。换句话说，交换需要访问预言机，以确保他们从 SwapX 获得的“最佳”执行价格足够接近预言机认为的“真实”价格。

> 什么是预言机？
>
> 预言机可以简单到只是对一对当前市场价格的链下观察。

由于套利的存在，通常情况下，一对的区块内储备比率接近“真实”市场价格。因此，如果用户在考虑到这些知识的情况下提交交易，他们可以确保由于抢先交易造成的损失受到严格限制。

这正是 SwapX 前端确保交易安全的方式：

* 它根&#x636E;_&#x89C2;察&#x5230;_&#x7684;块内价格计算最佳输入/输出量。
* 然后使用路由器执行交换，这保证交换以不低&#x4E8E;_&#x89C2;察到的块内汇率差_ $$ $x\%$ $$ 的汇率执行。
* $$ $x$ $$ 是用户指定的滑点容忍度（默认为 0.5%）。

***

#### ➡️ Exact Input (确切的输入)

如果您希望发送精确数量的输入代币以换取尽可能多的输出代币，则需要使用 `getAmountsOut`。

* SDK 等效函数： `getOutputAmount` (或用于滑点计算的 `minimumAmountOut`)。

#### ⬅️ Exact Output (确切的输出)

如果您希望以尽可能少的输入代币获得准确数量的输出代币，则需要使用 `getAmountsIn`。

* SDK 等效函数： `getInputAmount` (或用于滑点计算的 `maximumAmountIn`)。
